<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pmemobj on PMem.io</title><link>https://pmem.io/blogs/pmemobj/</link><description>Recent content in pmemobj on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 19 Jun 2015 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/pmemobj/index.xml" rel="self" type="application/rss+xml"/><item><title>An introduction to pmemobj (part 7) - persistent lists</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-7-persistent-lists/</link><pubDate>Fri, 19 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-7-persistent-lists/</guid><description>The pmemobj library provides non-transactional persistent atomic circular doubly-linked lists (or NTPACDLL for short) API with an interface familiar to anyone who have ever included sys/queue.h header file - it&amp;rsquo;s in fact so similar that I considered not writing this post at all, you can just search the web for CIRCLEQ example.
Fun fact: The exact same list code is used internally by libpmemobj in the transaction undo log implementation.</description></item><item><title>An introduction to pmemobj (part 5) - atomic dynamic memory allocation</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-5-atomic-dynamic-memory-allocation/</link><pubDate>Thu, 18 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-5-atomic-dynamic-memory-allocation/</guid><description>In the previous post I talked about using transactions for allocating new objects, which is fine and is the most similar approach to the standard POSIX way. But it does add an overhead of maintaining an undo log of changes. A more optimal memory management can be achieved using the non-transactional atomic API the pmemobj library provides.
Fail-safe atomic allocations This API is not similar to the APIs most programmers are used to when it comes to handling memory.</description></item><item><title>An introduction to pmemobj (part 6) - threading</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-6-threading/</link><pubDate>Thu, 18 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-6-threading/</guid><description>All of the pmemobj library functions are thread-safe, with following two exceptions: pool management functions (open, close and friends) and pmemobj_root when providing different sizes in different threads - so as long as you are using this function the way it&amp;rsquo;s meant to be used you don&amp;rsquo;t have to worry about it. As for macros - generally only the FOREACH macros are not thread-safe for obvious reasons.
Synchronization If you need to put a lock inside a structure that resides on persistent memory, our library provides pthread-like API for that purpose.</description></item><item><title>An introduction to pmemobj (part 4) - transactional dynamic memory allocation</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-4-transactional-dynamic-memory-allocation/</link><pubDate>Wed, 17 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-4-transactional-dynamic-memory-allocation/</guid><description>This is a topic I intentionally avoided not to introduce too much complexity too fast. The pmemobj library contains an implemented from scratch memory allocator, that was designed with persistent memory in mind. There are two separate APIs: non-transactional and transactional.
Transactional allocations Let&amp;rsquo;s start with a simple snippet of volatile code:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct rectangle { int a; int b; }; int area*calc(const struct rectangle \_rect) { return rect-&amp;gt;a * rect-&amp;gt;b; } .</description></item><item><title>An introduction to pmemobj (part 3) - types</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-3-types/</link><pubDate>Tue, 16 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-3-types/</guid><description>In all of the previous post the code snippets and examples had persistent pointers (PMEMoid) without any type information - they were simple C structures. Very early in the development of the library we discovered that using something like that was extremely error-prone and generally difficult. That&amp;rsquo;s why considerable effort was put into encapsulating the PMEMoids with type-safe container. The end result can be compared with how shared_ptr and the like are done in C++11.</description></item><item><title>An introduction to pmemobj (part 2) - transactions</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/</link><pubDate>Mon, 15 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/</guid><description>By now you should be fairly familiar with the basics persistent memory programming, but to make sure the application is always in a consistent state you had to rely on your own solutions and tricks - like the length of a buffer in the previous example. Now, we will learn a generic solution provided by pmemobj to this type of problems - transactions. For now we will focus on a single-threaded applications with no locking.</description></item><item><title>An introduction to pmemobj (part 1) - accessing the persistent memory</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/</link><pubDate>Sat, 13 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/</guid><description>In the previous post, you learned a little bit about the general concept of the persistent memory programming model, now it&amp;rsquo;s time to start the coding ;)
Memory pools If you&amp;rsquo;ve read the overview you know that persistent memory is exposed by the OS as memory-mapped files, we call them pools.
The pmemobj library provides an interface to easily manage those pools, so that you don&amp;rsquo;t have to manually create the files or mmap them.</description></item></channel></rss>