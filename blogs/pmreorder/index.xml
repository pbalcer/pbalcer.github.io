<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pmreorder on PMem.io</title><link>https://pmem.io/blogs/pmreorder/</link><description>Recent content in pmreorder on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 04 Feb 2019 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/pmreorder/index.xml" rel="self" type="application/rss+xml"/><item><title>Pmreorder basics</title><link>https://pmem.io/blog/2019/02/pmreorder-basics/</link><pubDate>Mon, 04 Feb 2019 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2019/02/pmreorder-basics/</guid><description>Introduction It&amp;rsquo;s good practice to run persistent memory application under pmemcheck - a tool which is described here and here.
In this post, we are going to learn about another tool for persistence correctness checking. As you might already know if you&amp;rsquo;ve read posts linked above, pmemcheck verifies if all stores are made persistent in a proper manner. Our new tool, pmreorder, extends this functionality. It traverses the sequences of stores between flush-fence barriers made by the application, and then replays these memory operations many times in different combinations, to simulate the various possible ways the stores to the NVDIMM could be ordered by the system.</description></item></channel></rss>