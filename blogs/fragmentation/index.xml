<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>fragmentation on PMem.io</title><link>https://pmem.io/blogs/fragmentation/</link><description>Recent content in fragmentation on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 25 Feb 2016 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/fragmentation/index.xml" rel="self" type="application/rss+xml"/><item><title>Persistent allocator design - fragmentation</title><link>https://pmem.io/blog/2016/02/persistent-allocator-design-fragmentation/</link><pubDate>Thu, 25 Feb 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/02/persistent-allocator-design-fragmentation/</guid><description>Implementing a memory allocator is a balance between numerous properties with the two most important being time and space constraints. Making the malloc/free routines reasonably fast is a must for the implementation to be considered usable at all. The algorithm also mustn&amp;rsquo;t waste excessive amounts of memory.
During development of the library we quickly realized that the performance characteristics will be dominated by the number of cache line flushes that will be required to perform operations in a fail-safe atomic way.</description></item></channel></rss>