<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pmemkv on PMem.io</title><link>https://pmem.io/blogs/pmemkv/</link><description>Recent content in pmemkv on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 30 Oct 2020 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/pmemkv/index.xml" rel="self" type="application/rss+xml"/><item><title>API overview of pmemkv-java binding</title><link>https://pmem.io/blog/2020/10/api-overview-of-pmemkv-java-binding/</link><pubDate>Fri, 30 Oct 2020 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2020/10/api-overview-of-pmemkv-java-binding/</guid><description>Pmemkv is a key-value data store written in C and C++, however, it also opens up a way to leverage persistent memory by developers who prefer high-level languages - such as Java. For more information about other bindings please read Language bindings for pmemkv article and pmemkv README
We built an API for pmemkv-java binding on top of libpmemkv 1.0 API, but java binding is also compatible with newer versions of libpmemkv.</description></item><item><title>Language bindings for pmemkv</title><link>https://pmem.io/blog/2020/03/language-bindings-for-pmemkv/</link><pubDate>Wed, 04 Mar 2020 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2020/03/language-bindings-for-pmemkv/</guid><description>pmemkv is a local/embedded key-value datastore optimized for persistent memory. It is written in C and C++, but to satisfy a wider audience it comes with several bindings for high-level languages. Currently: Java (with JNI), Node.js, Python and Ruby.
The picture below illustrates architecture and software stack of pmemkv and its bindings. The most up-to-date information about pmemkv and its bindings is located in pmemkv&amp;rsquo;s README file.
Common for bindings There are few common characteristics of all bindings:</description></item><item><title>Benchmarking with different storage engines using pmemkv</title><link>https://pmem.io/blog/2017/12/benchmarking-with-different-storage-engines-using-pmemkv/</link><pubDate>Wed, 27 Dec 2017 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2017/12/benchmarking-with-different-storage-engines-using-pmemkv/</guid><description>We&amp;rsquo;re closing out 2017 with two big improvements to pmemkv: support for multiple storage engines, and an improved benchmarking utility based on db_bench. These changes set the stage for some interesting experiments to come next year, as we continue to add new features and tune performance of pmemkv and its utilities and bindings.
Multiple storage engines A new virtual interface (KVEngine) was recently introduced that allows pmemkv to provide multiple storage engine implementations, without changes to utilities or language bindings or applications using the pmemkv API.</description></item><item><title>Zero-copy leaf splits in pmemkv</title><link>https://pmem.io/blog/2017/03/zero-copy-leaf-splits-in-pmemkv/</link><pubDate>Thu, 09 Mar 2017 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2017/03/zero-copy-leaf-splits-in-pmemkv/</guid><description>In a B+ tree, splitting a full leaf into two leaves is one of its slowest operations, but pmemkv optimizes this using a zero-copy strategy. Rather then copying any key/value data between full and new leaf, pmemkv splits leaves by swapping persistent structures in place. This minimizes write amplification and increases performance compared to copying, especially for larger key/value sizes.
The diagram below illustrates a persistent leaf being split. A &amp;lsquo;slot&amp;rsquo; is the term used in pmemkv for the grouping of a key, the Pearson hash for the key, and the value for the key.</description></item><item><title>Introducing pmemkv</title><link>https://pmem.io/blog/2017/02/introducing-pmemkv/</link><pubDate>Tue, 21 Feb 2017 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2017/02/introducing-pmemkv/</guid><description>We&amp;rsquo;ve blogged before about building and optimizing key-value stores for persistent memory, and we&amp;rsquo;re excited to put these ideas to the test in a more formal way.
Our new pmemkv project is an open-source key-value store that is optimized for read-heavy workloads on persistent memory. Compared with key-value stores based on the LSM algorithm, pmemkv offers higher read performance and lower write amplification. But our intent is not to deter use of LSM, only to expand the choices developers and architects have for aligning workloads to backing stores.</description></item></channel></rss>