<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Libpmemobj-cpp on PMem.io</title><link>https://pmem.io/blogs/libpmemobj-cpp/</link><description>Recent content in Libpmemobj-cpp on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 30 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://pmem.io/blogs/libpmemobj-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Libpmemobj-cpp - lessons learned</title><link>https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate><guid>https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/</guid><description>Introduction We&amp;rsquo;ve been working on C++ bindings for libpmemobj since around 2016 - see our very first tutorial for libpmemobj-cpp. We&amp;rsquo;ve come a long way since then. A lot has changed - we&amp;rsquo;ve gained more experience and knowledge, added new features, fixed quite a few bugs, and created at least half a dozen new containers. It&amp;rsquo;s fair to state this product is now far more mature and well-developed. Over time, we&amp;rsquo;ve learned at least several lessons about designing and overcoming issues in C++ applications for persistent memory.</description></item><item><title>Concurrency considerations in libpmemobj-cpp</title><link>https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate><guid>https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/</guid><description>Introduction Ensuring data consistency on pmem is a challenging task. It gets even more complicated if data is modified concurrently. This blog post describes several challenges related to data visibility, using transactions in multi-threaded environments, and memory leaks.
Lock-free programming on pmem A fundamental issue (if eADR is not used) is data visibility. When a thread issues a temporal (e.g., MOV) store instruction, the modification might be visible to other threads before it is persistent (data can still be in a CPU cache).</description></item><item><title>C++ persistent containers - vector</title><link>https://pmem.io/blog/2019/02/c-persistent-containers-vector/</link><pubDate>Wed, 20 Feb 2019 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2019/02/c-persistent-containers-vector/</guid><description>[Note: pmem::obj::vector&amp;lt;&amp;gt; is no longer experimental. The rest of the information in this blog post is still accurate.] Introduction The main idea behind pmem containers is to fully exploit persistent memory potential by designing optimized on-media layouts and algorithms for persistent memory programming. On November, we published a blog post about pmem containers. If you havenâ€™t read it yet, I encourage you to do that now.
We have recently added pmem::obj:experimental:vector container to libpmemobj-cpp library.</description></item><item><title>C++ persistent containers</title><link>https://pmem.io/blog/2018/11/c-persistent-containers/</link><pubDate>Tue, 20 Nov 2018 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2018/11/c-persistent-containers/</guid><description>PMEM containers Our goal for the libpmemobj C++ bindings is to create a friendly and less error prone API for persistent memory programming. Even with persistent memory pool allocators, convenient interface for creating and managing transactions, auto-snapshotting class templates and smart persistent pointers, designing an application with persistent memory usage may still prove challenging without a plethora of niceties that the C++ programmers are used to.
The natural step forward to make persistent programming easier, is to provide programmers with efficient and useful containers.</description></item><item><title>C++ persistent containers - array</title><link>https://pmem.io/blog/2018/11/c-persistent-containers-array/</link><pubDate>Fri, 02 Nov 2018 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2018/11/c-persistent-containers-array/</guid><description>Introduction Until now, our C++ bindings were missing one important component - persistent containers. In 1.5 release we have introduced the first one - pmem::obj::array. This container is currently placed in experimental namespace and folder (this means that both API and layout can change). It has almost the same functionality as std::array from C++11 but takes care of adding elements to a transaction. Once experimental status will be dropped, it will also guarantee a stable in-memory layout (it will be the same for all compilers).</description></item></channel></rss>