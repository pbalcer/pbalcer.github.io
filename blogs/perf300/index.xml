<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>perf300 on PMem.io</title><link>https://pmem.io/blogs/perf300/</link><description>Recent content in perf300 on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 26 Mar 2020 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/perf300/index.xml" rel="self" type="application/rss+xml"/><item><title>300 nanoseconds (2 of 2)</title><link>https://pmem.io/blog/2020/03/300-nanoseconds-2-of-2/</link><pubDate>Thu, 26 Mar 2020 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2020/03/300-nanoseconds-2-of-2/</guid><description>At the end of the first part of this blog series, I posed three fundamental questions regarding the design of failure atomic data structures for persistent memory.
What does it mean to allocate persistent memory? How to do fail-safe atomic updates? Are all data structures suitable for persistent memory? This time around, I will try to answer these questions to the best of my ability. We will return to the doubly-linked list example to see how it can be modified for PMEM.</description></item><item><title>300 nanoseconds (1 of 2)</title><link>https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/</link><pubDate>Thu, 19 Dec 2019 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/</guid><description>Educating people has always been a challenge for me. I tend to skip over things I wrongly consider obvious, or do large leaps in reasoning when explaining a solution to a problem. And so, when faced with an attempt to explain a complex topic, I tend to ramble on and on, hoping that the audience knows when to interrupt me if I go too fast. However, this doesn&amp;rsquo;t hold true for blog posts, such as the one I&amp;rsquo;m currently writing.</description></item></channel></rss>