<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>model on PMem.io</title><link>https://pmem.io/blogs/model/</link><description>Recent content in model on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 12 Jun 2015 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/model/index.xml" rel="self" type="application/rss+xml"/><item><title>An introduction to pmemobj (part 0) - new programming model</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-0-new-programming-model/</link><pubDate>Fri, 12 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-0-new-programming-model/</guid><description>The aim of this tutorial series is to introduce you to programming with persistent, byte-addressable memory using the pmemobj library. We will go over all the available features, implement an example application and learn something about the inner workings of libpmemobj. If you haven&amp;rsquo;t read the NVM Library overview I encourage you to do that now.
When designing the library API, we&amp;rsquo;ve put a heavy emphasis on ease of use and &amp;ldquo;management explainability&amp;rdquo;, as well as flexibility and performance.</description></item></channel></rss>