<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pmem on PMem.io</title><link>https://pmem.io/blogs/pmem/</link><description>Recent content in pmem on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 20 Oct 2015 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/pmem/index.xml" rel="self" type="application/rss+xml"/><item><title>Evaluation of a better object container</title><link>https://pmem.io/blog/2015/10/evaluation-of-a-better-object-container/</link><pubDate>Tue, 20 Oct 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/10/evaluation-of-a-better-object-container/</guid><description>During performance evaluation of our library, I asked myself a following question:
Which data structure has computational complexity of &amp;ldquo;insert at end&amp;rdquo; and &amp;ldquo;remove given element&amp;rdquo; operations no worse than a doubly-linked list, but with a smaller constant?
The point of that mental exercise was to come up with a persistent data structure that could replace doubly-linked list in object stores (right now a linked lists of every single user-allocated object) and undo logs.</description></item><item><title>Crawl, Walk, Run...</title><link>https://pmem.io/blog/2014/08/crawl-walk-run.../</link><pubDate>Wed, 27 Aug 2014 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2014/08/crawl-walk-run.../</guid><description>If you can&amp;rsquo;t fly then run, if you can&amp;rsquo;t run then walk, if you can&amp;rsquo;t walk then crawl, but whatever you do you have to keep moving forward.
Martin Luther King Jr.
This project, as well as the support for persistent memory in various operating systems, can be thought of as a crawl, walk, run approach. As byte-addressable persistence enters the market, modified system BIOS images and device drivers expose it to other modules in the kernel.</description></item><item><title>References</title><link>https://pmem.io/blog/2014/08/references/</link><pubDate>Tue, 26 Aug 2014 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2014/08/references/</guid><description>Some very interesting research has been happening in the area of Persistent Memory and more is emerging. While the examples provided here are meant as introductory and simple, some publications cover the topic in much more depth and include complete transaction systems, compiler/language enhancements, etc. Here are some of the most important publications in this space (please send links to more and we&amp;rsquo;ll include them).
One of the most impressive bodies of work in this area is Mnemosyne.</description></item><item><title>Creating pmem.io</title><link>https://pmem.io/blog/2014/08/creating-pmem.io/</link><pubDate>Mon, 25 Aug 2014 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2014/08/creating-pmem.io/</guid><description>The pmem project in GitHub has been created as an open source project focused on persistent memory programming. Everything on this web site and the associated GitHub repositories is open source under the &amp;ldquo;three-clause&amp;rdquo; BSD license.
Some educational Linux examples are included, which demonstrate the SNIA NVM programming model and some of the interesting features and challenges associated with persistent memory.
The team&amp;rsquo;s initial focus is the Linux NVM Library which will provide useful APIs for memory allocation, transactions, etc.</description></item></channel></rss>