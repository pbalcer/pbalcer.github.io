<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>libpmemobj on PMem.io</title><link>https://pmem.io/blogs/libpmemobj/</link><description>Recent content in libpmemobj on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 17 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://pmem.io/blogs/libpmemobj/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency considerations in libpmemobj-cpp</title><link>https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate><guid>https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/</guid><description>Introduction Ensuring data consistency on pmem is a challenging task. It gets even more complicated if data is modified concurrently. This blog post describes several challenges related to data visibility, using transactions in multi-threaded environments, and memory leaks.
Lock-free programming on pmem A fundamental issue (if eADR is not used) is data visibility. When a thread issues a temporal (e.g., MOV) store instruction, the modification might be visible to other threads before it is persistent (data can still be in a CPU cache).</description></item><item><title>Modeling strings with libpmemobj C++ bindings</title><link>https://pmem.io/blog/2017/01/modeling-strings-with-libpmemobj-c-bindings/</link><pubDate>Mon, 23 Jan 2017 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2017/01/modeling-strings-with-libpmemobj-c-bindings/</guid><description>C++ developers using libpmemobj have more than one option for modeling strings, depending on the size of the strings and whether they are fixed or varying in length. In this post we&amp;rsquo;ll review the representations that work, known variations to avoid, and finally present a persistent string class that implements these best practices.
Avoid wrapping fixed-size arrays You might expect (like I did at first!) that p&amp;lt;char[size]&amp;gt; is a proper way to simply model a fixed-size string, but actually this is not correct.</description></item><item><title>libpmemobj - a year in review</title><link>https://pmem.io/blog/2016/12/libpmemobj-a-year-in-review/</link><pubDate>Tue, 20 Dec 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/12/libpmemobj-a-year-in-review/</guid><description>It&amp;rsquo;s been a while since the last post on our blog, but we&amp;rsquo;ve been busy with the recently released 1.2 version of the library. It comes packed with improvements all throughout the code base and it also brings a handful of new features that we hope will end up being useful.
With the year coming to an end, it&amp;rsquo;s a good time to look back and discuss the things we&amp;rsquo;ve learned and accomplished.</description></item><item><title>C++ bindings for libpmemobj (epilogue) - converting existing applications</title><link>https://pmem.io/blog/2016/06/c-bindings-for-libpmemobj-epilogue-converting-existing-applications/</link><pubDate>Thu, 02 Jun 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/06/c-bindings-for-libpmemobj-epilogue-converting-existing-applications/</guid><description>During the development of the C++ bindings, we wrote a couple of examples and even more tests. But these are new applications written from scratch to understand persistence. While this approach is OK for newly developed apps, there is a lot of existing code out there that is not designed for persistent memory. It would be a real shame, if the existing solutions couldn&amp;rsquo;t benefit from the existence of persistent memory because of the amount of work needed to redesign and change them.</description></item><item><title>C++ bindings for libpmemobj (part 7) - synchronization primitives</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-7-synchronization-primitives/</link><pubDate>Tue, 31 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-7-synchronization-primitives/</guid><description>To finish off the C++ bindings to libpmemobj blog marathon, I will introduce to you the synchronization mechanisms we implemented. They are mostly C++11-like implementations of different kinds of mutexes and the condition variable. They satisfy their respective concepts (Mutex, SharedMutex and so on), the difference is that they are based on the persistent memory resident synchronization primitives provided by libpmemobj.
Mutex The pmem::obj::mutex class satisfies the requirements of the Mutex and StandardLayoutType concepts.</description></item><item><title>C++ bindings for libpmemobj (part 6) - transactions</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-6-transactions/</link><pubDate>Wed, 25 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-6-transactions/</guid><description>As I mentioned in my previous blog post, transactions are the heart of libpmemobj. That is why we had to take utmost care while designing their C++ versions, so that they are as easy to use as possible. There are, however, a couple of compromises we had to make due to the inadequacies of the C++11 standard. That is why we encourage using the lambda, until the C++17 standard is more widely implemented.</description></item><item><title>C++ bindings for libpmemobj (part 5) - make_persistent</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-5-make_persistent/</link><pubDate>Thu, 19 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-5-make_persistent/</guid><description>One of the most important features of the C++ bindings to libpmemobj is the persistent_ptr smart pointer template. While using it is fairly straightforward, the allocation and object construction with the use of the C API is hard to get right. So like it&amp;rsquo;s C++ standard&amp;rsquo;s counterparts, it needed an allocation mechanism with appropriate object construction. This is exactly what this post will try to explain.
Transactional allocations Probably the most common usage of the allocating functions is within pmemobj transactions.</description></item><item><title>C++ bindings for libpmemobj (part 4) - pool handle wrapper</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-4-pool-handle-wrapper/</link><pubDate>Tue, 10 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-4-pool-handle-wrapper/</guid><description>One of the necessary steps in developing the C++ libpmemobj bindings was the introduction of an abstraction of the C pool handle. We decided to do a very simple hierarchy where the pool template inherits from a generic pool_base. This was necessary to be able to have functions/methods which do not depend on the pool&amp;rsquo;s template argument. Please note that this makes both of these handles impossible to keep in persistent memory, due to the presence of a vtable.</description></item><item><title>C++ bindings for libpmemobj (part 0)</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-0/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-0/</guid><description>Our goal for the C pmemobj library was to make a fully featured implementation of persistent memory programming model without modifying the compiler. It&amp;rsquo;s meant for authors of very low-level system software and language creators. It&amp;rsquo;s not particularly pretty nor easy to use. The amount of macros, as well as the trickery inside them, might &amp;lsquo;amaze&amp;rsquo; even the biggest preprocessor fans ;)
The natural next step is to leverage the high-level languages features to create a more friendly, less error prone and generally nicer API.</description></item><item><title>C++ bindings for libpmemobj (part 1) - pmem resident variables</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-1-pmem-resident-variables/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-1-pmem-resident-variables/</guid><description>One of the biggest hurdles and error prone things about our C API is that the user has to manually keep track of modifications to the persistent memory resident variables while in a transaction. A special semi-transparent template property class has been implemented to automatically add variable modifications to the transaction undo log.
pmem::obj::p Let&amp;rsquo;s start with the vector example from the previous tutorial series. It looked like this:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct vector { int x; int y; int z; } PMEMoid root = pmemobj_root(pop, sizeof (struct vector)); struct vector \*vectorp = pmemobj_direct(root); TX_BEGIN(pop) { pmemobj_tx_add_range(root, 0, sizeof (struct vector)); vectorp-&amp;gt;x = 5; vectorp-&amp;gt;y = 10; vectorp-&amp;gt;z = 15; } TX_END As you can see, the programmer has to remember to call pmemobj_tx_add_range function before any modifications to the memory.</description></item><item><title>C++ bindings for libpmemobj (part 2) - persistent smart pointer</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-2-persistent-smart-pointer/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-2-persistent-smart-pointer/</guid><description>In our C API the programmer has to deal with custom pointers represented by the PMEMoid structure. Thanks to some macro magic we made it so that those PMEMoids are somewhat usable. C++ allows us to evolve this concept.
pmem::obj::persistent_ptr Almost everyone who ever touched a C++ code knows the idea behind smart pointers (for example, std::shared_ptr). Our persistent pointer works in the same way. It wraps around a type and provides implementation of operator*, operator-&amp;gt; and operator[].</description></item><item><title>C++ bindings for libpmemobj (part 3) - persistent queue example</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-3-persistent-queue-example/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-3-persistent-queue-example/</guid><description>The best way to learn to code is usually by implementing an example. We are going to be creating a linked-list based queue data structure using the the pmem::obj::p and pmem::obj::persistent_ptr classes and libpmemobj C API. But first, a little bit of CS 101 :)
Linked-list queue Queue is a collection of elements with two important operations:
push - adds element to the tail of the structure pop - removes element from the head of the structure This makes the queue a First-In-First-Out (FIFO) data structure.</description></item></channel></rss>